---
title: "5.6. Adjust configuration: branches mapping"
category: subchapter
booktype: remote
weight: 14
---
###5.6. Adjust configuration: branches mapping

    [svn]
    ...
    url = http://host/svn/repos

svn.url option value specifies project location. It is used as the root URL relative to which mappings paths are treated.

    [svn]
    ...
    trunk = trunk:refs/heads/master
    branches = branches/*:refs/heads/*
    tags = tags/*:refs/tags/*
    shelves = shelves/*:refs/shelves/*

There are four kinds of branches that have to be mapped, each represented by its own option: *trunk*, *branches*, *tags* and *shelves*. Each option establishes SVN\_PATH to GIT\_REFERENCE correspondence for a particular kind of entity. Mapping syntax for *trunk* is:

    trunk = SVN_PATH:GIT_REFERENCE

svn.trunk option allows to specify single SVN\_PATH:GI\_REFERENCE mapping as its value. SVN\_PATH is a path relative to the project svn.url location and GIT\_REFERENCE is a git reference e.g. refs/heads/master. Mapping meaning is that changes made on or below SVN\_PATH in Subversion project translated to the Git commits on GIT\_REFERENCE and conversely, commits on GIT\_REFERENCE would be translated to the changes below SVN\_PATH. Mapping syntax for **branches**, **tags** and **shelves** is:

    branches = SVN_PATH[/*]:GIT_REFERENCE[/*][;MAPPING]

These option allows to specify multiple mappings and each mapping may define many-to-many relationship. Mapping could be either one-to-one or many-to-many, in other words when '\*' wildcard is used it should be present in the both sides of mapping. Each of the options must contain at least one many-to-many mapping (one with '\*' wildcard). For example:

    branches = branches/*:refs/heads/*;release_branches/b1:refs/release/b1

Above mapping maps all branches in Subversion branches directory to the Git refs/heads namespace and, additionally, maps single release\_branches/b1 branch to refs/releases/b1 Git branch reference.

    branches = branches/*:refs/heads/*
    branches = branches/*/*:refs/heads/*/*
    branches = branches/*/project:refs/heads/*
    branches = branches/feature_*_2015:refs/heads/features/*

Wildcard related mapping syntax rules:
- Each mapping could include zero or more '*' on both sides (sides are separated by ':') of the definition.
- Each path or namespace segment should contain no more than one '*'.
- Number of '*' on the left side of the mapping must be equal to the number of '*' on the right side of it.

Shelves are special kind of branches used by SubGit to represent Git anonymous branches in Subversion repository.

**Figure 5.6. Shelves**
![Adjust configuration: branches mapping]({{ site.baseurl }}/img/remotebook/shelves-example.png)

Let's talk about it in some details. There are three most common cases here.
First, if the 'foo' branch is already synchronised with SVN, as both 'master' and 'foo' are mapped to ^/trunk and ^/branches/foo respectively.
Branches mapping looks like:
    
    trunk:refs/heads/master
    branches/*:refs/heads/*
    shelves/*:refs/shelves/*

In that case, when SubGit/SVN Mirror sends commit M to SVN repository, it commits revision rM on ^/trunk with log message of commit M, with tree changes of commit M; revision rM also updates svn:mergeinfo properly of ^/trunk, so merge history of ^/trunk now includes ^/branches/foo at rC and rD. 
When `svn log ^/trunk` command is run, one can find revision rM in the output, but not revisions rC and rD, however, if one'd run `svn log -g ^/trunk` the output should include both rC and rD.

In second case, Foo branch is not yet mapped to any branch in SVN repository. As result SubGit/SVN Mirror did not yet synchronized commits C and D with SVN repository, so they exist in Git repository only.
Branches mapping looks the same here as in the first case:

    trunk:refs/heads/master
    branches/*:refs/heads/*
    shelves/*:refs/shelves/*

When SubGit/SVN Mirror handles commit M it also finds not-yet-synchronized commits C and D, so it has to send these two commits first. Since there's no mapping for Foo branch, SubGit has to fallback to shelves/* mappings and so it creates the following revisions:

    rD: commit D sent to ^/shelves/auto-generated-shelf
    rC: commit C sent to ^/shelves/auto-generated-shelf

Finally, when both C and D are synchronized with SVN repository, SubGit/SVN Mirror commits revision rM on ^/trunk with log message of commit M, with tree changes of commit M; revision rM also updates svn:mergeinfo property of ^/trunk, so merge history of ^/trunk now includes ^/shelves/auto-generated-shelf at rC and rD. Finally rM deletes branch ^/shelves/auto-generated-shelf as it is already merged to ^/trunk and is not needed anymore.

Again, if one runs `svn log ^/trunk` one can not find revision rC and rD, however, if one'd run `svn log -g ^/trunk` the output should include both rC and rD of ^/shelves/auto-generated-shelf.

Please note if you'd have the following branches mapping enabled:

    trunk:refs/heads/master
    branches/*:refs/heads/*
    branches/foo/*:refs/heads/foo/*
    shelves/*:refs/shelves/*

SubGit/SVN Mirror would send both commits C and D to ^/branches/foo, i.e. scenario #1 should work in this case.

And so there is a third case, when there is no shelves/* mapping in SubGit/SVN Mirror configuration.
Branches mapping would look like this:

    trunk:refs/heads/master
    branches/*:refs/heads/*

Since version 3.0 both SubGit and SVN Mirror add-on support branches mappings with no shelves involved. In this case SubGit/SVN Mirror just ignores both commits C and D as there's no SVN branch they can be applied to. As result, SubGit/SVN Mirror send one single commit M to SVN repository and corresponding revision rM has log message of commit M, tree changes of commit M, but it does not update svn:mergeinfo property on ^/trunk. That means both `svn log ^/trunk` and `svn log -g ^/trunk` do not include changes C and D as they don't present in SVN repository.

There is also one little trick for cases #2 and #3:

If commit M has some standard log message, e.g. 'Merge branch foo into bar' or 'Merge branch foo', SubGit/SVN Mirror immediately understands that commits C and D belong to branch 'foo' in Git repository and branch 'foo' is mapped to ^/branches/foo. As result SubGit/SVN Mirror sends both commits C and D to ^/branches/foo; merges ^/branches/foo into ^/trunk and deletes ^/branches/foo within revision rM.

With shelves/* mapping disabled (case #3) this trick is rather powerful. Git committer has the following choice:

a) Merge branch 'foo' into 'master' and use descriptive message for a merge commit.

In this case SubGit/SVN Mirror creates one single revision with that descriptive message on ^/trunk; those commits on branch 'foo' remain in Git repository only.

b) Merge branch 'foo' into 'master' and use standard merge message "Merge branch foo".

In this case SubGit/SVN Mirror creates multiple revision on branch ^/branches/foo and then merges that branch into ^/trunk, one can see the whole history by running `svn log -g ^/trunk`.

Now off to the **exclude branch** option.
You can exclude branches, tags and paths from translaion:
Mappings could be refined by specifying patterns that controls what branches and tags
are excluded from the translation.

    excludeBranches = SIMPLE_PATTERN

Value of excludeBranches option is simple path matching pattern, with zero or one '*' symbol.
Branch path relative to the Subversion project URL is matched against the pattern specified.

To include or exclude particular files or directories within any of the branches or tags, use the following options:
    
    excludePath = PATTERN
    includePath = PATTERN

Value of excludePath and includePath options is a pattern in format same to that used in .gitignore file.
Only non-recursive patterns are supported by includePath option (pattern should start with '/').
Paths being matched against the patterns are relative to the branch or tag path.
See <http://git-scm.com/docs/gitignore> for complete documentation on the pattern format.

When branches, tags or paths is excluded from the translation with the help of one of the above options, modifications to those branches or paths made in Subversion project would not be translated to Git, as well as changes in Git repository made to those locations would not appear in Subversion.

Be careful when specifying mapping, it would not be possible to adjust it when synchronization is enabled. Only branches and tags that are included in the mapping will be imported and kept in sync by SubGit.

[](#up)